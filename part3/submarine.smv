MODULE emergency
VAR
  air_level: 0..10;
  status: boolean;

ASSIGN
  init (status) := case 
    air_level <= 5: TRUE;
    air_level > 5: FALSE;
  esac;
  next(status) := case
    air_level <= 5: TRUE;
    air_level > 5: FALSE;
  esac;
  
  -- Air level cannot be negative
  LTLSPEC
    G(air_level >= 0)

  -- The alarm fires only when there is no oxygen
  LTLSPEC
    G (air_level < 5 -> status = TRUE)

MODULE Crew(surface, hatch, alarm, territory)
  VAR
    role: {captain, sailor};
    hatch_command : {no, open, close};
    surface_command : {no, up, down};

  ASSIGN
    init(role) := {captain, sailor};
    next(role) := case
      TRUE : {captain, sailor}; -- random role
    esac;

    init(hatch_command) := {no};
    next(hatch_command) := case
      role = sailor & surface < 10 : {close, no};
      role = sailor & hatch = open : {close, no};
      role = sailor & hatch = close : {open, no};
      TRUE: no;
    esac;

    init(surface_command) := {no};
    next(surface_command) := case
      alarm.status = TRUE & surface < 10: up;
      role = captain & surface = 10 & territory = friendly: {down, no};
      role = captain & surface = 10 & territory != friendly: down;
      role = captain & surface < 10 : {up, no};
      TRUE: no;
    esac;

  FAIRNESS
    role = captain;
  FAIRNESS
    role = sailor;

  -- Only the sailor can give the hatch command (the command applies in the next state)
  LTLSPEC
    G(X(hatch_command = close | hatch_command = open) -> role = sailor)
  -- The command to go up is given only by the captain or by everyone if the alarm is raised
  LTLSPEC
    G(X (surface_command = up) -> role = captain | alarm.status = TRUE)

  -- The down command can be given only by the captaun when the alarm is off
  LTLSPEC
    G(X (surface_command = down & alarm.status = FALSE) -> role = captain)


MODULE main
VAR
  surface:   0..10;
  hatch:   { open, close };
  territory:   { friendly, enemy };
  alarm: emergency; --use alarm.status (boolean)
  order: Crew(surface, hatch, alarm, territory);

ASSIGN
  init (surface) := 0..10; -- The reboot of the system works
  next (surface) := case
		    surface < 10 & alarm.status = TRUE: surface + 1;
        surface > 0 & surface < 10 & territory=friendly & order.surface_command = no : surface;
        surface > 0 & surface < 10 & territory=friendly & order.surface_command = up : surface + 1;
        surface > 0 & surface < 10 & territory=friendly & order.surface_command = down: surface - 1;
        surface > 0 & surface < 10 & territory=friendly : {surface, surface - 1, surface + 1};
        surface = 10 & order.surface_command = down & hatch = close : surface - 1; 
        surface = 10 & order.surface_command = no : surface;
		    TRUE:                             surface;

  esac;

  init (hatch) := case
    surface = 10: {open, close};
    surface < 10: {close};
  esac; 
  next (hatch) := case
        surface = 10 & order.hatch_command = no: hatch;
        surface = 10 & order.hatch_command = close : close;
		    TRUE:            hatch;
  esac;

  init (territory) := {friendly, enemy};
  next (territory) := case
		    surface = 10: friendly;
		    surface < 10: {friendly, enemy};
		    TRUE:            territory;
  esac;

  init (alarm.air_level) := 0..10; -- set to the maximum to have the full picture, lower to 5 for debugging reasons
  next(alarm.air_level) := case
    alarm.air_level > 0 & surface < 10 : alarm.air_level - 1;
    surface = 10 & hatch = open: 10;
    TRUE:     alarm.air_level;
  esac;

-- The submarine eventually goes to surface
LTLSPEC
	G(surface < 10 -> F surface = 10)

-- The hatch is always close if the submarine is under surface
LTLSPEC
	G(surface < 10 -> hatch=close)

-- If the submarine is at surface and it is in friendly territory, the inmediate location should be also in friendly territory
LTLSPEC
	G(territory=friendly & surface=10 -> next(territory)=friendly)


